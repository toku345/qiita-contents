---
title: RDS上の各テーブルの成長をDatadogで見える化してみたよ
tags:
  - Ruby
  - Datadog
private: false
updated_at: '2023-08-09T11:47:40+09:00'
id: 62ca0decd8e219f6d3d2
organization_url_name: null
slide: false
---

# 目的

日々、成長していく（= データ量が増えていく）RDS を見守るために、見える化したい！
そのために Datadog にメトリクスを送ってグラフ化してみました！

# 想定する対象の方

以下のような方が読んでも分かるようなものを目指してます

- Datadog のアカウントは持ってるよ（持ってるだけだよ）
- Datadog のアカウントは持ってないけど雰囲気だけ知りたいよ

※ アカウント作成に関しては Developers.IO さんの記事が詳しいです
→ [Amazon Linux を Datadog で監視してみた](http://dev.classmethod.jp/cloud/aws/datadog-amazonlinux/)

# そもそも Datadog って？

非常に柔軟なモニタリングサービスで、Saas の形で提供されています。
グラフがとても綺麗にできます。
`tag`というものが有り、それを使うと多次元に解析できたりもします。

一言で言うと、ホントにすごい奴です！

### 情報源

[Datadog 本家](https://www.datadoghq.com/)

Datadog についてもちょっと深掘りしたい方は、
私のココロの師匠 @akiray03 さんの[はじめての datadog](http://qiita.com/akiray03/items/ac10748fc6d273ef33fb)

Datadog `tag` のすごさ、多次元に解析については、
@jhotta さんの[Datadog の本当の魅力とは](http://qiita.com/jhotta/items/e7e20a1acd797bf2665b)を参照ください。

# 見える化のために

## メトリクス（= 監視したい情報）の送信

### 手段その１（REST API 経由）

最初はメトリクス送信に`REST API`を使用してみました。

[Datadog API Reference](http://docs.datadoghq.com/ja/api/)
`DATADOG_KEY`, `DATADOG_APP_KEY`はコチラから → https://app.datadoghq.com/account/settings#api

コードはこんな感じ ↓

```ruby:rds_tables.rb
#! /usr/bin/env ruby
require 'dogapi'

DATADOG_KEY     = 'XXXXXXXXXX'
DATADOG_APP_KEY = 'XXXXXXXXXX'

def emit_datadog(metric, v, tags)
  dog = Dogapi::Client.new(DATADOG_KEY, DATADOG_APP_KEY)
  dog.emit_point(metric, v, host: 'my.host', tags: tags)
end

SQL = 'SELECT TABLE_NAME, TABLE_ROWS, DATA_LENGTH, INDEX_LENGTH FROM information_schema.tables WHERE TABLE_SCHEMA="myapp";'

records = `mysql -uwho -ppassword -h hogehoge.ap-northeast-1.rds.amazonaws.com my_database -BN -e '#{SQL}'`
records.split("\n").each do |record|
  table_name, table_rows, data_length, index_length = record.split("\t")
  emit_datadog 'myapp.mysql.table_rows',   table_rows.to_i,   ['mysql', "table_name:#{table_name}", 'table_rows']   # テーブル行数
  emit_datadog 'myapp.mysql.data_length',  data_length.to_i,  ['mysql', "table_name:#{table_name}", 'data_length']  # テーブルサイズ
  emit_datadog 'myapp.mysql.index_length', index_length.to_i, ['mysql', "table_name:#{table_name}", 'index_length'] # インデックスサイズ
end
```

ただ上記コードには問題がありました 😥
各テーブル × メトリクス毎に送信する必要があるため、
約 300 テーブル × 3 メトリクス = 約 900 回 https 通信が発生し、9 分位かかってました。。。
リアルタイム性に欠けるため、とても監視につかえるようなしろものではありませんでした。

### 手段その２（DogStatsD 経由）

そこで、DogStatsD 経由で送信するように変更してみました。

DogStatsD を使うと
`メトリクスをUDPを使って受信し、集計した後、グラフ化表示のために定期的にDatadog側に送信`できるようになり、
約 300 テーブルある情報を１分間隔で送信しても特にトラブルが起きなくなりました！

[DogStatsD の解説](http://docs.datadoghq.com/ja/api/)

※ ちなみに DogStatsD を使用するためには`Datadog Agent`のセットアップが必要みたいです。
[Datadog Agent 入門](http://docs.datadoghq.com/ja/guides/basic_agent_usage/)

```ruby:rds_tables2.rb
#! /usr/bin/env ruby
require 'statsd'

statsd = Statsd.new('localhost')

SQL = 'SELECT TABLE_NAME, TABLE_ROWS, DATA_LENGTH, INDEX_LENGTH FROM information_schema.tables WHERE TABLE_SCHEMA="myapp";'

records = `mysql -uwho -ppassword -h hogehoge.ap-northeast-1.rds.amazonaws.com my_database -BN -e '#{SQL}'`
statsd.batch do |s|
  records.split("\n").each do |record|
    table_name, table_rows, data_length, index_length = record.split("\t")
    s.gauge 'myapp.mysql.table_rows',   table_rows.to_i,   tags: ['mysql', "table_name:#{table_name}", 'table_rows']   # テーブル行数
    s.gauge 'myapp.mysql.data_length',  data_length.to_i,  tags: ['mysql', "table_name:#{table_name}", 'data_length']  # テーブルサイズ
    s.gauge 'myapp.mysql.index_length', index_length.to_i, tags: ['mysql', "table_name:#{table_name}", 'index_length'] # インデックスサイズ
  end
end
```

## グラフ化

お次は集めたメトリクスのグラフ化！

### グラフの準備

まずは、集めたメトリクスのうち、どのメトリクスを使ってグラフを描画するかを指定します。

サイドメニューの [Metrics] -> [Explorer] を選択
![1.png](https://qiita-image-store.s3.amazonaws.com/0/13998/85c42799-fd7f-ab34-fc40-5edde4d18261.png)

[Graph]欄にメトリクス名を指定して、グラフを任意の数（今回は１つ）選択し、新しくダッシュボードを作成
![2.png](https://qiita-image-store.s3.amazonaws.com/0/13998/0bf1f504-c7a9-c764-44f4-e2155c356448.png)

![3.png](https://qiita-image-store.s3.amazonaws.com/0/13998/3e5e1037-8485-84c7-db5e-b3f837d03e3c.png)

### ダッシュボードの修正

前の手順でグラフは出来たのですが、もう一手間かけるともっと使い勝手の良いものになります！

ダッシュボードを開いて
![4.png](https://qiita-image-store.s3.amazonaws.com/0/13998/df665e92-5f68-d824-8700-93a1784f2179.png)

`Template Variable`を設定
![5.png](https://qiita-image-store.s3.amazonaws.com/0/13998/e700134c-efff-540d-35f8-d7ef05bfc75a.png)

最初に設定したグラフから新しく設定した`Template Variable`を参照するように変更
![6.png](https://qiita-image-store.s3.amazonaws.com/0/13998/dd62c7bf-8d54-9921-ff08-deb0362a0ed3.png)

画面上部の`Template Variable`を変更してやると、その値に応じてグラフが変更するようになります
![7.png](https://qiita-image-store.s3.amazonaws.com/0/13998/55b34f85-49ea-04dd-9fb1-062bc3fae8d2.png)

いいですね！！

他のメトリクスも同じように設定して、しばらく放置すると ↓ のような感じになります。
是非、みなさまも面白そうなメトリクスを追加＆グラフ化して楽しんでみてください！

※ 下の画像は今回作成したグラフの他に Top List というグラフも表示させてます。
![8.png](https://qiita-image-store.s3.amazonaws.com/0/13998/de7a8775-1ae0-591b-3924-85ea10a10035.png)
